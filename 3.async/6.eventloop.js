//  计算机分配任务的最小单位是什么？   进程是最小单位   每一个应用程序都是一个进程

// 浏览器是一个多进程模型（每个页卡都是一个独立的进程，其中一个挂了不会导致整个浏览器挂了）

// 浏览器中进程的组成： 
// 主进程（负责创建和销毁的）  
// 渲染进程（每个页卡都有一个） 
// 网络进程（发送http请求） 
// 插件（独立的进程） 
// gpu绘图进程


// 渲染进程（线程）
// ui渲染  gui渲染线程  渲染页面/布局/画页面
// js引擎线程  执行js代码的  js单独的线程（主线程是单线程）  和渲染进程是互斥的，防止混乱，边操作增加删除边渲染


// 在js中的执行过程中还会创建一些其他的线程   定时器、 http请求 、事件
// 我们在执行js引擎线程上正在执行代码  可能定时器到时间了，用户点击按钮了。我们要规划执行的顺序，事件环就是用来规定怎么调度执行的

// 事件环：无线循环的线程（事件触发线程）目的就是为了调度任务的

// 分类（都是异步的）
// 宏任务：<script>、ui渲染、定时器setTimeOut、ajax、http请求、事件(用户操作click/mousemove)、messgaeChanel、setImmediate(IE下)
// 微任务：原生的promise、mutationObserver、node中的process.nextTick、queueMicroTask

// 异步方法：requestFrameAnimation requestIDleCallback(这两个方法是跟渲染相关的，不算事件环的一部分，但是也有人把它们规划成宏任务)



// 默认是要先执行一个script脚本（微任务先执行，这个说法不对）因为script是一个宏任务
// 在代码执行的时候会调用对应的setTimeout，ajax，事件 调用webAPI的时候，例如定时器时间到达后会将回调放到队列中（消息队列）
// 宏任务队列只有一个，微任务队列每次执行宏任务的时候会将微任务的方法放到队列中（创建一个新队列）

// 主栈代码执行完毕后，会查找所有的微任务将其执行并清空，如果微任务嵌套会将生成的新的微任务放到本次队列的后边
// 微任务执行完毕后，要检测是否需要渲染，浏览器有自己的刷新频率，渲染是在宏任务之前做的
// 再去宏任务队列中取出一个宏任务执行此流程


// 如果宏任务空了，事件触发线程就会进入到休眠状态，等待宏任务中有新任务，按照流程继续执行
// 执行代码完毕后，会清空微任务（执行多个），宏任务每次只执行一个


// 消息队列 其实在内部是有多个队列组成的，理解的时候我们说宏任务只有一个
// 一个任务队列(集合) 是有多个队列组成的  每个队列中有多个任务
// 选择要执行的队列

// 我们直接理解成只有一个宏任务队列（其实是有多个的）
// 宏任务是一个独立的队列  每次宏任务会产生一个微任务队列
